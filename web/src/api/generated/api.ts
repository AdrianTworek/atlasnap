/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * Atlasnap API
 * Travel memory storage and organization SaaS
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BatchConfirmRequest,
  BatchConfirmResponse,
  BatchUploadRequest,
  BatchUploadResponse,
  BearerResponse,
  BodyAuthJwtLoginApiV1AuthJwtLoginPost,
  BodyResetForgotPasswordApiV1AuthForgotPasswordPost,
  BodyResetResetPasswordApiV1AuthResetPasswordPost,
  BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost,
  BodyVerifyVerifyApiV1AuthVerifyPost,
  DownloadUrlResponse,
  ErrorModel,
  HTTPValidationError,
  HealthCheckResponse,
  ListMediaApiV1MediaGetParams,
  MediaList,
  MediaRead,
  MediaUpdate,
  OAuth2AuthorizeResponse,
  OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams,
  OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams,
  RootResponse,
  UserCreate,
  UserRead,
  UserUpdate
} from './models';

import { apiClient } from '../client';
/**
 * @summary Auth:Jwt.Login
 */
export const authJwtLoginApiV1AuthJwtLoginPost = (
    bodyAuthJwtLoginApiV1AuthJwtLoginPost: BodyAuthJwtLoginApiV1AuthJwtLoginPost,
 signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyAuthJwtLoginApiV1AuthJwtLoginPost.grant_type !== undefined && bodyAuthJwtLoginApiV1AuthJwtLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.grant_type);
 }
formUrlEncoded.append(`username`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.username);
formUrlEncoded.append(`password`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.password);
if(bodyAuthJwtLoginApiV1AuthJwtLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.scope);
 }
if(bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_id !== undefined && bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_id);
 }
if(bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_secret !== undefined && bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyAuthJwtLoginApiV1AuthJwtLoginPost.client_secret);
 }

      return apiClient<BearerResponse>(
      {url: `http://localhost:8000/api/v1/auth/jwt/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      );
    }
  


export const getAuthJwtLoginApiV1AuthJwtLoginPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginApiV1AuthJwtLoginPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginApiV1AuthJwtLoginPost}, TContext> => {

const mutationKey = ['authJwtLoginApiV1AuthJwtLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>, {data: BodyAuthJwtLoginApiV1AuthJwtLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  authJwtLoginApiV1AuthJwtLoginPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLoginApiV1AuthJwtLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>>
    export type AuthJwtLoginApiV1AuthJwtLoginPostMutationBody = BodyAuthJwtLoginApiV1AuthJwtLoginPost
    export type AuthJwtLoginApiV1AuthJwtLoginPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Auth:Jwt.Login
 */
export const useAuthJwtLoginApiV1AuthJwtLoginPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginApiV1AuthJwtLoginPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLoginApiV1AuthJwtLoginPost>>,
        TError,
        {data: BodyAuthJwtLoginApiV1AuthJwtLoginPost},
        TContext
      > => {
      return useMutation(getAuthJwtLoginApiV1AuthJwtLoginPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Auth:Jwt.Logout
 */
export const authJwtLogoutApiV1AuthJwtLogoutPost = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `http://localhost:8000/api/v1/auth/jwt/logout`, method: 'POST', signal
    },
      );
    }
  


export const getAuthJwtLogoutApiV1AuthJwtLogoutPostMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>, TError,void, TContext> => {

const mutationKey = ['authJwtLogoutApiV1AuthJwtLogoutPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>, void> = () => {
          

          return  authJwtLogoutApiV1AuthJwtLogoutPost()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLogoutApiV1AuthJwtLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>>
    
    export type AuthJwtLogoutApiV1AuthJwtLogoutPostMutationError = void

    /**
 * @summary Auth:Jwt.Logout
 */
export const useAuthJwtLogoutApiV1AuthJwtLogoutPost = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLogoutApiV1AuthJwtLogoutPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthJwtLogoutApiV1AuthJwtLogoutPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Register:Register
 */
export const registerRegisterApiV1AuthRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getRegisterRegisterApiV1AuthRegisterPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerRegisterApiV1AuthRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerRegisterApiV1AuthRegisterPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterRegisterApiV1AuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>>
    export type RegisterRegisterApiV1AuthRegisterPostMutationBody = UserCreate
    export type RegisterRegisterApiV1AuthRegisterPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Register:Register
 */
export const useRegisterRegisterApiV1AuthRegisterPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerRegisterApiV1AuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {
      return useMutation(getRegisterRegisterApiV1AuthRegisterPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Reset:Forgot Password
 */
export const resetForgotPasswordApiV1AuthForgotPasswordPost = (
    bodyResetForgotPasswordApiV1AuthForgotPasswordPost: BodyResetForgotPasswordApiV1AuthForgotPasswordPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `http://localhost:8000/api/v1/auth/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetForgotPasswordApiV1AuthForgotPasswordPost, signal
    },
      );
    }
  


export const getResetForgotPasswordApiV1AuthForgotPasswordPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordApiV1AuthForgotPasswordPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordApiV1AuthForgotPasswordPost}, TContext> => {

const mutationKey = ['resetForgotPasswordApiV1AuthForgotPasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>, {data: BodyResetForgotPasswordApiV1AuthForgotPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetForgotPasswordApiV1AuthForgotPasswordPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ResetForgotPasswordApiV1AuthForgotPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>>
    export type ResetForgotPasswordApiV1AuthForgotPasswordPostMutationBody = BodyResetForgotPasswordApiV1AuthForgotPasswordPost
    export type ResetForgotPasswordApiV1AuthForgotPasswordPostMutationError = HTTPValidationError

    /**
 * @summary Reset:Forgot Password
 */
export const useResetForgotPasswordApiV1AuthForgotPasswordPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordApiV1AuthForgotPasswordPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetForgotPasswordApiV1AuthForgotPasswordPost>>,
        TError,
        {data: BodyResetForgotPasswordApiV1AuthForgotPasswordPost},
        TContext
      > => {
      return useMutation(getResetForgotPasswordApiV1AuthForgotPasswordPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Reset:Reset Password
 */
export const resetResetPasswordApiV1AuthResetPasswordPost = (
    bodyResetResetPasswordApiV1AuthResetPasswordPost: BodyResetResetPasswordApiV1AuthResetPasswordPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `http://localhost:8000/api/v1/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetResetPasswordApiV1AuthResetPasswordPost, signal
    },
      );
    }
  


export const getResetResetPasswordApiV1AuthResetPasswordPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordApiV1AuthResetPasswordPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordApiV1AuthResetPasswordPost}, TContext> => {

const mutationKey = ['resetResetPasswordApiV1AuthResetPasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>, {data: BodyResetResetPasswordApiV1AuthResetPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetResetPasswordApiV1AuthResetPasswordPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ResetResetPasswordApiV1AuthResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>>
    export type ResetResetPasswordApiV1AuthResetPasswordPostMutationBody = BodyResetResetPasswordApiV1AuthResetPasswordPost
    export type ResetResetPasswordApiV1AuthResetPasswordPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Reset:Reset Password
 */
export const useResetResetPasswordApiV1AuthResetPasswordPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordApiV1AuthResetPasswordPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetResetPasswordApiV1AuthResetPasswordPost>>,
        TError,
        {data: BodyResetResetPasswordApiV1AuthResetPasswordPost},
        TContext
      > => {
      return useMutation(getResetResetPasswordApiV1AuthResetPasswordPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Verify:Request-Token
 */
export const verifyRequestTokenApiV1AuthRequestVerifyTokenPost = (
    bodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `http://localhost:8000/api/v1/auth/request-verify-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost, signal
    },
      );
    }
  


export const getVerifyRequestTokenApiV1AuthRequestVerifyTokenPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost}, TContext> => {

const mutationKey = ['verifyRequestTokenApiV1AuthRequestVerifyTokenPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>, {data: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyRequestTokenApiV1AuthRequestVerifyTokenPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRequestTokenApiV1AuthRequestVerifyTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>>
    export type VerifyRequestTokenApiV1AuthRequestVerifyTokenPostMutationBody = BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost
    export type VerifyRequestTokenApiV1AuthRequestVerifyTokenPostMutationError = HTTPValidationError

    /**
 * @summary Verify:Request-Token
 */
export const useVerifyRequestTokenApiV1AuthRequestVerifyTokenPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyRequestTokenApiV1AuthRequestVerifyTokenPost>>,
        TError,
        {data: BodyVerifyRequestTokenApiV1AuthRequestVerifyTokenPost},
        TContext
      > => {
      return useMutation(getVerifyRequestTokenApiV1AuthRequestVerifyTokenPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Verify:Verify
 */
export const verifyVerifyApiV1AuthVerifyPost = (
    bodyVerifyVerifyApiV1AuthVerifyPost: BodyVerifyVerifyApiV1AuthVerifyPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyVerifyApiV1AuthVerifyPost, signal
    },
      );
    }
  


export const getVerifyVerifyApiV1AuthVerifyPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>, TError,{data: BodyVerifyVerifyApiV1AuthVerifyPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>, TError,{data: BodyVerifyVerifyApiV1AuthVerifyPost}, TContext> => {

const mutationKey = ['verifyVerifyApiV1AuthVerifyPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>, {data: BodyVerifyVerifyApiV1AuthVerifyPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyVerifyApiV1AuthVerifyPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyVerifyApiV1AuthVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>>
    export type VerifyVerifyApiV1AuthVerifyPostMutationBody = BodyVerifyVerifyApiV1AuthVerifyPost
    export type VerifyVerifyApiV1AuthVerifyPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Verify:Verify
 */
export const useVerifyVerifyApiV1AuthVerifyPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>, TError,{data: BodyVerifyVerifyApiV1AuthVerifyPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyVerifyApiV1AuthVerifyPost>>,
        TError,
        {data: BodyVerifyVerifyApiV1AuthVerifyPost},
        TContext
      > => {
      return useMutation(getVerifyVerifyApiV1AuthVerifyPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Users:Current User
 */
export const usersCurrentUserApiV1AuthMeGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/me`, method: 'GET', signal
    },
      );
    }
  



export const getUsersCurrentUserApiV1AuthMeGetQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/auth/me`
    ] as const;
    }

    
export const getUsersCurrentUserApiV1AuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersCurrentUserApiV1AuthMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>> = ({ signal }) => usersCurrentUserApiV1AuthMeGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersCurrentUserApiV1AuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>>
export type UsersCurrentUserApiV1AuthMeGetQueryError = void


export function useUsersCurrentUserApiV1AuthMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersCurrentUserApiV1AuthMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersCurrentUserApiV1AuthMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Users:Current User
 */

export function useUsersCurrentUserApiV1AuthMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserApiV1AuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersCurrentUserApiV1AuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Users:Patch Current User
 */
export const usersPatchCurrentUserApiV1AuthMePatch = (
    userUpdate: UserUpdate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/me`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate, signal
    },
      );
    }
  


export const getUsersPatchCurrentUserApiV1AuthMePatchMutationOptions = <TError = ErrorModel | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['usersPatchCurrentUserApiV1AuthMePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  usersPatchCurrentUserApiV1AuthMePatch(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersPatchCurrentUserApiV1AuthMePatchMutationResult = NonNullable<Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>>
    export type UsersPatchCurrentUserApiV1AuthMePatchMutationBody = UserUpdate
    export type UsersPatchCurrentUserApiV1AuthMePatchMutationError = ErrorModel | void | HTTPValidationError

    /**
 * @summary Users:Patch Current User
 */
export const useUsersPatchCurrentUserApiV1AuthMePatch = <TError = ErrorModel | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersPatchCurrentUserApiV1AuthMePatch>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {
      return useMutation(getUsersPatchCurrentUserApiV1AuthMePatchMutationOptions(options), queryClient);
    }
    
/**
 * @summary Users:User
 */
export const usersUserApiV1AuthIdGet = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getUsersUserApiV1AuthIdGetQueryKey = (id: string,) => {
    return [
    `http://localhost:8000/api/v1/auth/${id}`
    ] as const;
    }

    
export const getUsersUserApiV1AuthIdGetQueryOptions = <TData = Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError = void | HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersUserApiV1AuthIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>> = ({ signal }) => usersUserApiV1AuthIdGet(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersUserApiV1AuthIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>>
export type UsersUserApiV1AuthIdGetQueryError = void | HTTPValidationError


export function useUsersUserApiV1AuthIdGet<TData = Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError = void | HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>,
          TError,
          Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersUserApiV1AuthIdGet<TData = Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError = void | HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>,
          TError,
          Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersUserApiV1AuthIdGet<TData = Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError = void | HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Users:User
 */

export function useUsersUserApiV1AuthIdGet<TData = Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError = void | HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserApiV1AuthIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersUserApiV1AuthIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Users:Patch User
 */
export const usersPatchUserApiV1AuthIdPatch = (
    id: string,
    userUpdate: UserUpdate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `http://localhost:8000/api/v1/auth/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate, signal
    },
      );
    }
  


export const getUsersPatchUserApiV1AuthIdPatchMutationOptions = <TError = ErrorModel | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>, TError,{id: string;data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>, TError,{id: string;data: UserUpdate}, TContext> => {

const mutationKey = ['usersPatchUserApiV1AuthIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>, {id: string;data: UserUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  usersPatchUserApiV1AuthIdPatch(id,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersPatchUserApiV1AuthIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>>
    export type UsersPatchUserApiV1AuthIdPatchMutationBody = UserUpdate
    export type UsersPatchUserApiV1AuthIdPatchMutationError = ErrorModel | void | HTTPValidationError

    /**
 * @summary Users:Patch User
 */
export const useUsersPatchUserApiV1AuthIdPatch = <TError = ErrorModel | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>, TError,{id: string;data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersPatchUserApiV1AuthIdPatch>>,
        TError,
        {id: string;data: UserUpdate},
        TContext
      > => {
      return useMutation(getUsersPatchUserApiV1AuthIdPatchMutationOptions(options), queryClient);
    }
    
/**
 * @summary Users:Delete User
 */
export const usersDeleteUserApiV1AuthIdDelete = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/auth/${id}`, method: 'DELETE', signal
    },
      );
    }
  


export const getUsersDeleteUserApiV1AuthIdDeleteMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['usersDeleteUserApiV1AuthIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  usersDeleteUserApiV1AuthIdDelete(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserApiV1AuthIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>>
    
    export type UsersDeleteUserApiV1AuthIdDeleteMutationError = void | HTTPValidationError

    /**
 * @summary Users:Delete User
 */
export const useUsersDeleteUserApiV1AuthIdDelete = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUserApiV1AuthIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getUsersDeleteUserApiV1AuthIdDeleteMutationOptions(options), queryClient);
    }
    
/**
 * @summary Oauth:Google.Jwt.Authorize
 */
export const oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet = (
    params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<OAuth2AuthorizeResponse>(
      {url: `http://localhost:8000/api/v1/auth/google/authorize`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryKey = (params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams,) => {
    return [
    `http://localhost:8000/api/v1/auth/google/authorize`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>> = ({ signal }) => oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>>
export type OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryError = HTTPValidationError


export function useOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params: undefined |  OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>,
          TError,
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>,
          TError,
          Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Oauth:Google.Jwt.Authorize
 */

export function useOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError = HTTPValidationError>(
 params?: OauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOauthGoogleJwtAuthorizeApiV1AuthGoogleAuthorizeGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * The response varies based on the authentication backend used.
 * @summary Oauth:Google.Jwt.Callback
 */
export const oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet = (
    params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `http://localhost:8000/api/v1/auth/google/callback`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryKey = (params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams,) => {
    return [
    `http://localhost:8000/api/v1/auth/google/callback`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryOptions = <TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>> = ({ signal }) => oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryResult = NonNullable<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>>
export type OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryError = ErrorModel | HTTPValidationError


export function useOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params: undefined |  OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Oauth:Google.Jwt.Callback
 */

export function useOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError = ErrorModel | HTTPValidationError>(
 params?: OauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oauthGoogleJwtCallbackApiV1AuthGoogleCallbackGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOauthGoogleJwtCallbackApiV1AuthGoogleCallbackGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Generate presigned URLs for uploading files.
 * @summary Get Upload Urls
 */
export const getUploadUrlsApiV1MediaUploadUrlsPost = (
    batchUploadRequest: BatchUploadRequest,
 signal?: AbortSignal
) => {
      
      
      return apiClient<BatchUploadResponse>(
      {url: `http://localhost:8000/api/v1/media/upload/urls`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchUploadRequest, signal
    },
      );
    }
  


export const getGetUploadUrlsApiV1MediaUploadUrlsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>, TError,{data: BatchUploadRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>, TError,{data: BatchUploadRequest}, TContext> => {

const mutationKey = ['getUploadUrlsApiV1MediaUploadUrlsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>, {data: BatchUploadRequest}> = (props) => {
          const {data} = props ?? {};

          return  getUploadUrlsApiV1MediaUploadUrlsPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetUploadUrlsApiV1MediaUploadUrlsPostMutationResult = NonNullable<Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>>
    export type GetUploadUrlsApiV1MediaUploadUrlsPostMutationBody = BatchUploadRequest
    export type GetUploadUrlsApiV1MediaUploadUrlsPostMutationError = HTTPValidationError

    /**
 * @summary Get Upload Urls
 */
export const useGetUploadUrlsApiV1MediaUploadUrlsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>, TError,{data: BatchUploadRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getUploadUrlsApiV1MediaUploadUrlsPost>>,
        TError,
        {data: BatchUploadRequest},
        TContext
      > => {
      return useMutation(getGetUploadUrlsApiV1MediaUploadUrlsPostMutationOptions(options), queryClient);
    }
    
/**
 * Confirm uploads after files are uploaded to S3.
 * @summary Confirm Uploads
 */
export const confirmUploadsApiV1MediaUploadConfirmPost = (
    batchConfirmRequest: BatchConfirmRequest,
 signal?: AbortSignal
) => {
      
      
      return apiClient<BatchConfirmResponse>(
      {url: `http://localhost:8000/api/v1/media/upload/confirm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchConfirmRequest, signal
    },
      );
    }
  


export const getConfirmUploadsApiV1MediaUploadConfirmPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>, TError,{data: BatchConfirmRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>, TError,{data: BatchConfirmRequest}, TContext> => {

const mutationKey = ['confirmUploadsApiV1MediaUploadConfirmPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>, {data: BatchConfirmRequest}> = (props) => {
          const {data} = props ?? {};

          return  confirmUploadsApiV1MediaUploadConfirmPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmUploadsApiV1MediaUploadConfirmPostMutationResult = NonNullable<Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>>
    export type ConfirmUploadsApiV1MediaUploadConfirmPostMutationBody = BatchConfirmRequest
    export type ConfirmUploadsApiV1MediaUploadConfirmPostMutationError = HTTPValidationError

    /**
 * @summary Confirm Uploads
 */
export const useConfirmUploadsApiV1MediaUploadConfirmPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>, TError,{data: BatchConfirmRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof confirmUploadsApiV1MediaUploadConfirmPost>>,
        TError,
        {data: BatchConfirmRequest},
        TContext
      > => {
      return useMutation(getConfirmUploadsApiV1MediaUploadConfirmPostMutationOptions(options), queryClient);
    }
    
/**
 * Get download URL for media.
 * @summary Get Download Url
 */
export const getDownloadUrlApiV1MediaMediaIdDownloadUrlGet = (
    mediaId: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<DownloadUrlResponse>(
      {url: `http://localhost:8000/api/v1/media/${mediaId}/download-url`, method: 'GET', signal
    },
      );
    }
  



export const getGetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryKey = (mediaId: string,) => {
    return [
    `http://localhost:8000/api/v1/media/${mediaId}/download-url`
    ] as const;
    }

    
export const getGetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryOptions = <TData = Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError = HTTPValidationError>(mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryKey(mediaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>> = ({ signal }) => getDownloadUrlApiV1MediaMediaIdDownloadUrlGet(mediaId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(mediaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>>
export type GetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryError = HTTPValidationError


export function useGetDownloadUrlApiV1MediaMediaIdDownloadUrlGet<TData = Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError = HTTPValidationError>(
 mediaId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>,
          TError,
          Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDownloadUrlApiV1MediaMediaIdDownloadUrlGet<TData = Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>,
          TError,
          Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDownloadUrlApiV1MediaMediaIdDownloadUrlGet<TData = Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Download Url
 */

export function useGetDownloadUrlApiV1MediaMediaIdDownloadUrlGet<TData = Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrlApiV1MediaMediaIdDownloadUrlGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDownloadUrlApiV1MediaMediaIdDownloadUrlGetQueryOptions(mediaId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * List user's media with filters.
 * @summary List Media
 */
export const listMediaApiV1MediaGet = (
    params?: ListMediaApiV1MediaGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<MediaList>(
      {url: `http://localhost:8000/api/v1/media`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListMediaApiV1MediaGetQueryKey = (params?: ListMediaApiV1MediaGetParams,) => {
    return [
    `http://localhost:8000/api/v1/media`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListMediaApiV1MediaGetQueryOptions = <TData = Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError = HTTPValidationError>(params?: ListMediaApiV1MediaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListMediaApiV1MediaGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>> = ({ signal }) => listMediaApiV1MediaGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListMediaApiV1MediaGetQueryResult = NonNullable<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>>
export type ListMediaApiV1MediaGetQueryError = HTTPValidationError


export function useListMediaApiV1MediaGet<TData = Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError = HTTPValidationError>(
 params: undefined |  ListMediaApiV1MediaGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMediaApiV1MediaGet>>,
          TError,
          Awaited<ReturnType<typeof listMediaApiV1MediaGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMediaApiV1MediaGet<TData = Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError = HTTPValidationError>(
 params?: ListMediaApiV1MediaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMediaApiV1MediaGet>>,
          TError,
          Awaited<ReturnType<typeof listMediaApiV1MediaGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMediaApiV1MediaGet<TData = Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError = HTTPValidationError>(
 params?: ListMediaApiV1MediaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Media
 */

export function useListMediaApiV1MediaGet<TData = Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError = HTTPValidationError>(
 params?: ListMediaApiV1MediaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMediaApiV1MediaGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListMediaApiV1MediaGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Get single media by ID.
 * @summary Get Media
 */
export const getMediaApiV1MediaMediaIdGet = (
    mediaId: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<MediaRead>(
      {url: `http://localhost:8000/api/v1/media/${mediaId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetMediaApiV1MediaMediaIdGetQueryKey = (mediaId: string,) => {
    return [
    `http://localhost:8000/api/v1/media/${mediaId}`
    ] as const;
    }

    
export const getGetMediaApiV1MediaMediaIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError = HTTPValidationError>(mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMediaApiV1MediaMediaIdGetQueryKey(mediaId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>> = ({ signal }) => getMediaApiV1MediaMediaIdGet(mediaId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(mediaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMediaApiV1MediaMediaIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>>
export type GetMediaApiV1MediaMediaIdGetQueryError = HTTPValidationError


export function useGetMediaApiV1MediaMediaIdGet<TData = Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError = HTTPValidationError>(
 mediaId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMediaApiV1MediaMediaIdGet<TData = Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMediaApiV1MediaMediaIdGet<TData = Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Media
 */

export function useGetMediaApiV1MediaMediaIdGet<TData = Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError = HTTPValidationError>(
 mediaId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMediaApiV1MediaMediaIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMediaApiV1MediaMediaIdGetQueryOptions(mediaId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Update media metadata.
 * @summary Update Media
 */
export const updateMediaApiV1MediaMediaIdPatch = (
    mediaId: string,
    mediaUpdate: MediaUpdate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<MediaRead>(
      {url: `http://localhost:8000/api/v1/media/${mediaId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: mediaUpdate, signal
    },
      );
    }
  


export const getUpdateMediaApiV1MediaMediaIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>, TError,{mediaId: string;data: MediaUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>, TError,{mediaId: string;data: MediaUpdate}, TContext> => {

const mutationKey = ['updateMediaApiV1MediaMediaIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>, {mediaId: string;data: MediaUpdate}> = (props) => {
          const {mediaId,data} = props ?? {};

          return  updateMediaApiV1MediaMediaIdPatch(mediaId,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMediaApiV1MediaMediaIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>>
    export type UpdateMediaApiV1MediaMediaIdPatchMutationBody = MediaUpdate
    export type UpdateMediaApiV1MediaMediaIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Media
 */
export const useUpdateMediaApiV1MediaMediaIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>, TError,{mediaId: string;data: MediaUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMediaApiV1MediaMediaIdPatch>>,
        TError,
        {mediaId: string;data: MediaUpdate},
        TContext
      > => {
      return useMutation(getUpdateMediaApiV1MediaMediaIdPatchMutationOptions(options), queryClient);
    }
    
/**
 * Delete media.
 * @summary Delete Media
 */
export const deleteMediaApiV1MediaMediaIdDelete = (
    mediaId: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/media/${mediaId}`, method: 'DELETE', signal
    },
      );
    }
  


export const getDeleteMediaApiV1MediaMediaIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>, TError,{mediaId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>, TError,{mediaId: string}, TContext> => {

const mutationKey = ['deleteMediaApiV1MediaMediaIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>, {mediaId: string}> = (props) => {
          const {mediaId} = props ?? {};

          return  deleteMediaApiV1MediaMediaIdDelete(mediaId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMediaApiV1MediaMediaIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>>
    
    export type DeleteMediaApiV1MediaMediaIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Media
 */
export const useDeleteMediaApiV1MediaMediaIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>, TError,{mediaId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMediaApiV1MediaMediaIdDelete>>,
        TError,
        {mediaId: string},
        TContext
      > => {
      return useMutation(getDeleteMediaApiV1MediaMediaIdDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Root endpoint.
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<RootResponse>(
      {url: `http://localhost:8000/`, method: 'GET', signal
    },
      );
    }
  



export const getRootGetQueryKey = () => {
    return [
    `http://localhost:8000/`
    ] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Health check endpoint.
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<HealthCheckResponse>(
      {url: `http://localhost:8000/health`, method: 'GET', signal
    },
      );
    }
  



export const getHealthCheckHealthGetQueryKey = () => {
    return [
    `http://localhost:8000/health`
    ] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
